<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Material Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lucide/0.263.0/lucide.min.js"></script>
    <style>
        .checkerboard {
            background-image: linear-gradient(45deg, #eee 25%, transparent 25%, transparent 75%, #eee 75%, #eee 100%), 
                              linear-gradient(45deg, #eee 25%, white 25%, white 75%, #eee 75%, #eee 100%);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
        }
        .custom-scrollbar::-webkit-scrollbar { width: 5px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        .loader { border-top-color: #3b82f6; animation: spinner 1s linear infinite; }
        @keyframes spinner { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        canvas {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: auto; 
        }

        .btn-toggle-active {
            background-color: #dbeafe !important;
            color: #2563eb !important;
            border-color: #3b82f6 !important;
        }

        .layer-card-active {
            border-color: #3b82f6 !important;
            background-color: #f8faff !important;
        }

        /* 预设色块样式 */
        .swatch {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(0,0,0,0.1);
        }
        .swatch:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
            z-index: 10;
        }

        /* 动画弹窗 */
        #color-picker-modal {
            transition: opacity 0.2s, transform 0.2s;
        }
        .tab-active {
            border-bottom: 2px solid #3b82f6;
            color: #3b82f6;
            font-weight: bold;
        }
    </style>
</head>
<body class="bg-slate-100 min-h-screen text-slate-800 font-sans select-none">

    <div class="flex h-screen overflow-hidden">
        <!-- 侧边栏 -->
        <aside class="w-80 bg-white border-r border-slate-200 flex flex-col shadow-xl z-20">
            <div class="p-6 border-b border-slate-100">
                <h1 class="text-xl font-bold flex items-center gap-2 text-slate-900">
                    <i data-lucide="palette" class="text-blue-600"></i>
                    Material Studio
                </h1>
                <p class="text-[10px] text-slate-400 mt-1 uppercase font-bold tracking-[0.2em]">Professional Vector Rendering</p>
            </div>

            <div class="flex-1 overflow-y-auto p-4 space-y-4 custom-scrollbar">
                <div id="drop-zone" class="border-2 border-dashed border-slate-200 rounded-xl p-6 text-center hover:bg-slate-50 transition-all cursor-pointer group">
                    <input type="file" id="pdf-input" class="hidden" accept=".pdf">
                    <i data-lucide="upload" class="mx-auto w-8 h-8 text-slate-300 mb-2 group-hover:text-blue-500 transition-colors"></i>
                    <p class="text-xs font-medium text-slate-600">点击加载 PDF 图纸</p>
                </div>

                <div id="settings-panel" class="hidden space-y-4 bg-slate-50 p-4 rounded-xl border border-slate-100">
                    <div class="flex items-center justify-between">
                        <span class="text-[10px] font-black text-slate-400 uppercase italic tracking-widest">全局配置</span>
                        <button id="reset-btn" class="text-[10px] text-red-500 hover:underline">重置</button>
                    </div>
                    
                    <div class="space-y-2">
                        <label class="text-[10px] text-slate-400 font-bold uppercase block">导出精度</label>
                        <select id="export-quality" class="w-full text-xs p-2 rounded-lg border border-slate-200 bg-white outline-none">
                            <option value="2">标准 (Draft)</option>
                            <option value="4" selected>高清 (HD - 300 DPI)</option>
                            <option value="6">超清 (600 DPI)</option>
                            <option value="12">极限 (1200 DPI)</option>
                        </select>
                    </div>

                    <div class="flex items-center gap-3">
                        <label class="text-xs text-slate-600 font-bold shrink-0">全局底色</label>
                        <div id="global-bg-trigger" class="flex-1 h-8 rounded-lg border border-slate-200 cursor-pointer shadow-sm relative overflow-hidden" style="background-color: #ffffff;"></div>
                    </div>
                </div>

                <div id="layer-container" class="space-y-3 hidden">
                    <h3 class="text-xs font-black text-slate-400 uppercase flex justify-between items-center tracking-widest px-1">
                        图层列表
                        <span id="layer-count" class="bg-blue-100 text-blue-600 px-2 py-0.5 rounded-full text-[9px]">0</span>
                    </h3>
                    <div id="layer-list" class="space-y-2">
                        <!-- 图层卡片 -->
                    </div>
                </div>
            </div>

            <div class="p-4 bg-slate-50 border-t border-slate-100">
                <button id="export-btn" class="w-full bg-slate-900 hover:bg-black disabled:bg-slate-300 text-white font-bold py-4 rounded-xl flex flex-col items-center justify-center transition-all shadow-xl" disabled>
                    <div class="flex items-center gap-2">
                        <i data-lucide="award" class="w-4 h-4 text-yellow-400"></i>
                        <span>生成高清 PNG</span>
                    </div>
                </button>
            </div>
        </aside>

        <!-- 主工作区 -->
        <main class="flex-1 relative flex flex-col overflow-hidden">
            <div id="loading-overlay" class="absolute inset-0 bg-white/95 backdrop-blur-md z-50 hidden flex-col items-center justify-center">
                <div class="loader ease-linear rounded-full border-4 border-t-4 border-slate-200 h-16 w-16 mb-4"></div>
                <p id="loading-text" class="text-sm font-bold text-slate-800"></p>
                <p id="render-progress" class="text-[11px] text-blue-600 mt-2 font-mono font-bold"></p>
            </div>

            <!-- 自定义色盘弹窗 (Modal) -->
            <div id="color-picker-backdrop" class="fixed inset-0 z-[100] hidden bg-black/5 backdrop-blur-[1px]"></div>
            <div id="color-picker-modal" class="fixed z-[101] hidden w-72 bg-white rounded-2xl shadow-2xl border border-slate-200 overflow-hidden flex flex-col">
                <!-- Tabs -->
                <div class="flex border-b border-slate-100 bg-slate-50">
                    <button class="flex-1 py-3 text-[10px] font-bold uppercase tracking-wider transition-all tab-btn tab-active" data-tab="custom">自定义</button>
                    <button class="flex-1 py-3 text-[10px] font-bold uppercase tracking-wider transition-all tab-btn" data-tab="preset">建筑预设</button>
                </div>

                <!-- Tab Content: Custom -->
                <div id="tab-custom" class="p-4 space-y-4">
                    <div class="flex flex-col gap-3">
                        <label class="text-[10px] text-slate-400 font-bold uppercase">颜色拾取</label>
                        <input type="color" id="modal-color-input" class="w-full h-12 rounded-xl cursor-pointer bg-transparent border-none">
                        <div class="flex items-center gap-2">
                            <span class="text-[10px] text-slate-400 font-bold">HEX:</span>
                            <input type="text" id="modal-hex-input" class="flex-1 text-xs font-mono p-1 bg-slate-100 rounded border-none uppercase text-blue-600 font-bold" value="#FFFFFF">
                        </div>
                    </div>
                </div>

                <!-- Tab Content: Preset -->
                <div id="tab-preset" class="hidden p-4 space-y-4 max-h-96 overflow-y-auto custom-scrollbar">
                    <div id="palette-content" class="space-y-4">
                        <!-- 分类色谱注入 -->
                    </div>
                </div>

                <div class="p-4 bg-slate-50 border-t border-slate-100 flex gap-2">
                    <button id="modal-clear-btn" class="flex-1 py-2 text-[10px] font-bold bg-white text-red-500 border border-slate-200 rounded-lg hover:bg-red-50">清除颜色</button>
                    <button id="modal-close-btn" class="flex-1 py-2 text-[10px] font-bold bg-slate-900 text-white rounded-lg hover:bg-black">确定</button>
                </div>
            </div>

            <div class="flex-1 overflow-auto flex items-center justify-center p-12 bg-slate-200/40">
                <div class="relative shadow-2xl bg-white checkerboard overflow-hidden rounded-sm" id="canvas-wrapper">
                    <canvas id="main-canvas"></canvas>
                </div>
            </div>

            <div class="absolute bottom-6 right-6 flex items-center bg-white/90 backdrop-blur-sm rounded-full shadow-2xl border border-slate-200 p-1 px-5 gap-5">
                <span id="zoom-text" class="text-xs font-black text-slate-600">100%</span>
                <div class="flex gap-3 border-l pl-5 border-slate-200">
                    <button id="zoom-out" class="p-1.5 hover:bg-slate-100 rounded-full transition-colors"><i data-lucide="minus-circle" class="w-5 h-5 text-slate-400"></i></button>
                    <button id="zoom-in" class="p-1.5 hover:bg-slate-100 rounded-full transition-colors"><i data-lucide="plus-circle" class="w-5 h-5 text-slate-400"></i></button>
                </div>
            </div>
        </main>
    </div>

    <script>
        // 建筑专业预设色谱
        const ARCH_PALETTES = {
            '植被景观': ['#99C68E', '#7CB342', '#558B2F', '#33691E', '#A5D6A7', '#C5E1A5', '#F1F8E9', '#2E7D32', '#689F38', '#DCEDC8'],
            '水体环境': ['#E1F5FE', '#B3E5FC', '#81D4FA', '#4FC3F7', '#039BE5', '#01579B', '#E0F7FA', '#B2EBF2', '#00ACC1', '#006064'],
            '铺装交通': ['#F5F5F5', '#EEEEEE', '#E0E0E0', '#BDBDBD', '#9E9E9E', '#757575', '#424242', '#212121', '#607D8B', '#455A64'],
            '结构核心': ['#000000', '#212121', '#424242', '#FF5252', '#D32F2F', '#FFD740', '#FFA000', '#B71C1C', '#FFEB3B', '#795548'],
            '室内空间': ['#FDF5E6', '#FFF8DC', '#F5F5DC', '#DEB887', '#D2B48C', '#BC8F8F', '#E9E4D4', '#D7CCC8', '#A1887F', '#8D6E63']
        };

        function refreshIcons() { if (typeof lucide !== 'undefined') lucide.createIcons(); }

        window.addEventListener('load', () => {
            if (typeof pdfjsLib !== 'undefined') {
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            }
            initCustomPicker();
            refreshIcons();
        });

        const pdfInput = document.getElementById('pdf-input');
        const dropZone = document.getElementById('drop-zone');
        const layerList = document.getElementById('layer-list');
        const layerContainer = document.getElementById('layer-container');
        const mainCanvas = document.getElementById('main-canvas');
        const bgColorTrigger = document.getElementById('global-bg-trigger');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const renderProgress = document.getElementById('render-progress');
        const exportBtn = document.getElementById('export-btn');
        const exportQuality = document.getElementById('export-quality');

        // Color Picker Modal Elements
        const colorPickerModal = document.getElementById('color-picker-modal');
        const colorPickerBackdrop = document.getElementById('color-picker-backdrop');
        const modalColorInput = document.getElementById('modal-color-input');
        const modalHexInput = document.getElementById('modal-hex-input');
        const modalClearBtn = document.getElementById('modal-clear-btn');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        const tabBtns = document.querySelectorAll('.tab-btn');
        const tabCustom = document.getElementById('tab-custom');
        const tabPreset = document.getElementById('tab-preset');
        const paletteContent = document.getElementById('palette-content');

        let currentPdf = null;
        let ocgConfig = null;
        let layers = [];
        let originalViewport = null;
        let zoom = 100;
        let isRendering = false;
        let currentPickingContext = { type: null, idx: -1 }; // type: 'layer' | 'global'

        // 初始化自定义色盘弹窗内容
        function initCustomPicker() {
            // 注入预设色谱
            paletteContent.innerHTML = '';
            Object.keys(ARCH_PALETTES).forEach(category => {
                const group = document.createElement('div');
                group.innerHTML = `<p class="text-[9px] text-slate-400 font-bold uppercase mb-2 tracking-tighter">${category}</p>`;
                const grid = document.createElement('div');
                grid.className = 'flex flex-wrap gap-2';
                ARCH_PALETTES[category].forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.className = 'swatch';
                    swatch.style.backgroundColor = color;
                    swatch.onclick = () => selectColor(color);
                    grid.appendChild(swatch);
                });
                group.appendChild(grid);
                paletteContent.appendChild(group);
            });

            // Tab 切换逻辑
            tabBtns.forEach(btn => {
                btn.onclick = () => {
                    tabBtns.forEach(b => b.classList.remove('tab-active'));
                    btn.classList.add('tab-active');
                    if (btn.dataset.tab === 'custom') {
                        tabCustom.classList.remove('hidden');
                        tabPreset.classList.add('hidden');
                    } else {
                        tabCustom.classList.add('hidden');
                        tabPreset.classList.remove('hidden');
                    }
                };
            });

            // 颜色输入同步
            modalColorInput.oninput = (e) => {
                modalHexInput.value = e.target.value.toUpperCase();
                selectColor(e.target.value, false);
            };
            modalHexInput.oninput = (e) => {
                let val = e.target.value;
                if (!val.startsWith('#')) val = '#' + val;
                if (/^#[0-9A-F]{6}$/i.test(val)) {
                    modalColorInput.value = val;
                    selectColor(val, false);
                }
            };

            // 关闭逻辑
            modalCloseBtn.onclick = closePicker;
            colorPickerBackdrop.onclick = closePicker;
            modalClearBtn.onclick = () => {
                if (currentPickingContext.type === 'layer') {
                    layers[currentPickingContext.idx].fillColor = null;
                }
                closePicker();
                renderLayerCards();
                renderStudio();
            };
        }

        function openPicker(type, idx, event) {
            currentPickingContext = { type, idx };
            const currentColor = type === 'layer' ? layers[idx].fillColor : bgColorTrigger.style.backgroundColor;
            
            // 同步当前颜色到输入框
            if (currentColor) {
                const hex = rgbToHex(currentColor) || currentColor;
                modalColorInput.value = hex;
                modalHexInput.value = hex.toUpperCase();
            }

            // 定位
            const rect = event.target.getBoundingClientRect();
            let top = rect.bottom + window.scrollY + 10;
            let left = rect.left + window.scrollX;
            
            // 边缘溢出检测
            if (top + 400 > window.innerHeight) top = rect.top + window.scrollY - 410;
            if (left + 300 > window.innerWidth) left = window.innerWidth - 320;

            colorPickerModal.style.top = `${top}px`;
            colorPickerModal.style.left = `${left}px`;
            colorPickerModal.classList.remove('hidden');
            colorPickerBackdrop.classList.remove('hidden');
        }

        function closePicker() {
            colorPickerModal.classList.add('hidden');
            colorPickerBackdrop.classList.add('hidden');
        }

        function selectColor(color, autoClose = true) {
            if (currentPickingContext.type === 'layer') {
                layers[currentPickingContext.idx].fillColor = color;
            } else {
                bgColorTrigger.style.backgroundColor = color;
            }
            
            modalColorInput.value = color;
            modalHexInput.value = color.toUpperCase();

            if (autoClose) closePicker();
            renderLayerCards();
            renderStudio();
        }

        function rgbToHex(rgb) {
            if (!rgb || !rgb.startsWith('rgb')) return rgb;
            const res = rgb.match(/\d+/g);
            return res ? "#" + res.slice(0, 3).map(x => parseInt(x).toString(16).padStart(2, '0')).join('') : rgb;
        }

        const showLoading = (t) => { 
            loadingText.textContent = t; 
            loadingOverlay.classList.remove('hidden'); 
            loadingOverlay.classList.add('flex'); 
        };
        const hideLoading = () => {
            loadingOverlay.classList.remove('flex');
            loadingOverlay.classList.add('hidden');
        };

        dropZone.onclick = () => pdfInput.click();
        pdfInput.onchange = (e) => handlePdf(e.target.files[0]);

        async function handlePdf(file) {
            if (!file) return;
            showLoading("正在提取 PDF 原始矢量路径...");
            try {
                const arrayBuffer = await file.arrayBuffer();
                currentPdf = await pdfjsLib.getDocument({ data: arrayBuffer, verbosity: 0 }).promise;
                ocgConfig = await currentPdf.getOptionalContentConfig();
                
                const groups = ocgConfig.getGroups();
                layers = Object.keys(groups).map(id => ({
                    id,
                    name: groups[id].name || `图层 ${id}`,
                    visible: true,
                    material: null,
                    materialScale: 1.0,
                    materialAngle: 0,
                    fillColor: null,
                    has3DEffect: false
                }));

                const page = await currentPdf.getPage(1);
                originalViewport = page.getViewport({ scale: 1.0 });
                
                renderLayerCards();
                await renderStudio();
                
                layerContainer.classList.remove('hidden');
                document.getElementById('settings-panel').classList.remove('hidden');
                exportBtn.disabled = false;
            } catch (err) {
                console.error(err);
                alert("加载失败");
            }
            hideLoading();
        }

        function renderLayerCards() {
            layerList.innerHTML = '';
            document.getElementById('layer-count').textContent = layers.length;
            
            layers.forEach((layer, idx) => {
                const card = document.createElement('div');
                card.className = "bg-white border border-slate-200 rounded-xl p-3 shadow-sm hover:border-blue-400 transition-all space-y-3";
                
                card.innerHTML = `
                    <div class="flex items-center justify-between gap-2">
                        <div class="flex items-center gap-2 overflow-hidden flex-1">
                            <input type="checkbox" ${layer.visible ? 'checked' : ''} class="layer-toggle w-3.5 h-3.5 rounded text-blue-600" data-idx="${idx}">
                            <span class="text-[11px] font-black truncate text-slate-700">${layer.name}</span>
                        </div>
                        <div class="flex items-center gap-1">
                            <button class="btn-3d text-[9px] p-1.5 bg-slate-100 text-slate-400 rounded-md hover:bg-blue-50 transition-colors border border-transparent ${layer.has3DEffect ? 'btn-toggle-active' : ''}" title="开启立体阴影" data-idx="${idx}">
                                <i data-lucide="box" class="w-3 h-3"></i>
                            </button>
                            <!-- 颜色触发器 -->
                            <div class="color-trigger w-5 h-5 rounded-full border border-slate-200 cursor-pointer shadow-sm relative overflow-hidden" 
                                 style="background-color: ${layer.fillColor || '#ffffff'}; ${layer.fillColor ? '' : 'opacity: 0.3;'}" 
                                 data-idx="${idx}">
                            </div>
                            <button class="mat-upload-btn text-[9px] px-2 py-1 bg-slate-900 text-white rounded-md font-bold hover:bg-blue-600" data-idx="${idx}">
                                材质
                            </button>
                        </div>
                        <input type="file" class="hidden mat-file-input" accept="image/*" data-idx="${idx}">
                    </div>
                    
                    <div class="mat-controls ${layer.material ? '' : 'hidden'} space-y-3 pt-2 border-t border-slate-50">
                        <div class="space-y-1.5">
                            <div class="flex justify-between items-center text-[9px] text-slate-400 uppercase font-black">
                                <span>缩放 (Scale)</span>
                                <div class="flex items-center gap-1 text-blue-600">
                                    <input type="number" step="0.001" value="${(layer.materialScale * 100).toFixed(1)}" class="scale-input w-12 bg-slate-50 rounded px-1 text-right outline-none">
                                    <span>%</span>
                                </div>
                            </div>
                            <input type="range" min="0.001" max="2.0" step="0.001" value="${layer.materialScale}" class="w-full h-1 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600 scale-slider" data-idx="${idx}">
                        </div>
                        <div class="space-y-1.5">
                            <div class="flex justify-between items-center text-[9px] text-slate-400 uppercase font-black">
                                <span>角度 (Angle)</span>
                                <div class="flex items-center gap-1 text-blue-600">
                                    <input type="number" step="1" value="${layer.materialAngle}" class="angle-input w-12 bg-slate-50 rounded px-1 text-right outline-none">
                                    <span>°</span>
                                </div>
                            </div>
                            <input type="range" min="0" max="360" step="1" value="${layer.materialAngle}" class="w-full h-1 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600 angle-slider" data-idx="${idx}">
                        </div>
                        <div class="h-10 w-full rounded border border-slate-100 checkerboard overflow-hidden relative group">
                             <img class="mat-preview h-full w-full object-cover" src="${layer.material ? layer.material.src : ''}">
                             <button class="absolute inset-0 bg-red-500/0 group-hover:bg-red-500/80 text-white opacity-0 group-hover:opacity-100 transition-all flex items-center justify-center mat-remove" data-idx="${idx}">
                                <i data-lucide="trash-2" class="w-4 h-4"></i>
                             </button>
                        </div>
                    </div>
                `;
                layerList.appendChild(card);

                // 事件绑定
                card.querySelector('.layer-toggle').onchange = (e) => { layers[idx].visible = e.target.checked; renderStudio(); };
                card.querySelector('.btn-3d').onclick = () => { layers[idx].has3DEffect = !layers[idx].has3DEffect; renderLayerCards(); renderStudio(); };
                card.querySelector('.color-trigger').onclick = (e) => openPicker('layer', idx, e);
                
                const matInput = card.querySelector('.mat-file-input');
                card.querySelector('.mat-upload-btn').onclick = () => matInput.click();
                matInput.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const url = URL.createObjectURL(file);
                    const img = new Image();
                    img.onload = () => { layers[idx].material = img; renderLayerCards(); renderStudio(); };
                    img.src = url;
                };

                const scaleSlider = card.querySelector('.scale-slider');
                const scaleInput = card.querySelector('.scale-input');
                const updateScale = (v) => { 
                    layers[idx].materialScale = parseFloat(v); 
                    scaleInput.value = (layers[idx].materialScale * 100).toFixed(1);
                    renderStudio(); 
                };
                scaleSlider.oninput = (e) => updateScale(e.target.value);
                scaleInput.onchange = (e) => { let v = parseFloat(e.target.value)/100; scaleSlider.value = v; updateScale(v); };

                const angleSlider = card.querySelector('.angle-slider');
                const angleInput = card.querySelector('.angle-input');
                const updateAngle = (v) => { 
                    layers[idx].materialAngle = parseInt(v) % 360; 
                    angleInput.value = layers[idx].materialAngle;
                    renderStudio(); 
                };
                angleSlider.oninput = (e) => updateAngle(e.target.value);
                angleInput.onchange = (e) => { angleSlider.value = e.target.value; updateAngle(e.target.value); };

                card.querySelector('.mat-remove').onclick = () => { layers[idx].material = null; renderLayerCards(); renderStudio(); };
            });
            refreshIcons();
        }

        bgColorTrigger.onclick = (e) => openPicker('global', -1, e);

        function processUltraHDMask(ctx, w, h) {
            const imgData = ctx.getImageData(0, 0, w, h);
            const data = imgData.data;
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] * 0.299 + data[i+1] * 0.587 + data[i+2] * 0.114);
                if (brightness > 220) {
                    const factor = (255 - brightness) / (255 - 220);
                    data[i+3] = Math.min(data[i+3], data[i+3] * factor);
                }
            }
            ctx.putImageData(imgData, 0, 0);
        }

        async function renderStudio(isExport = false) {
            if (!currentPdf || !originalViewport || isRendering) return;
            isRendering = true;

            const ctx = mainCanvas.getContext('2d');
            const renderScale = isExport ? parseFloat(exportQuality.value) : 2.0; 
            const page = await currentPdf.getPage(1);
            const viewport = page.getViewport({ scale: renderScale });

            mainCanvas.width = viewport.width;
            mainCanvas.height = viewport.height;
            if (!isExport) updateZoom();

            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            ctx.fillStyle = bgColorTrigger.style.backgroundColor || '#ffffff';
            ctx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);

            const baseLayers = layers.filter(l => l.visible && !l.material && !l.fillColor);
            const processedLayers = layers.filter(l => l.visible && (l.material || l.fillColor));

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = mainCanvas.width;
            tempCanvas.height = mainCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.imageSmoothingEnabled = true;
            tempCtx.imageSmoothingQuality = 'high';

            if (baseLayers.length > 0) {
                layers.forEach(l => ocgConfig.setVisibility(l.id, baseLayers.some(bl => bl.id === l.id)));
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                await page.render({ canvasContext: tempCtx, viewport, optionalContentConfigPromise: Promise.resolve(ocgConfig) }).promise;
                processUltraHDMask(tempCtx, tempCanvas.width, tempCanvas.height);
                ctx.drawImage(tempCanvas, 0, 0);
            }

            for (let layer of processedLayers) {
                if (isExport) renderProgress.textContent = `Rendering... ${layer.name}`;
                layers.forEach(l => ocgConfig.setVisibility(l.id, l.id === layer.id));
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                await page.render({ canvasContext: tempCtx, viewport, optionalContentConfigPromise: Promise.resolve(ocgConfig) }).promise;
                processUltraHDMask(tempCtx, tempCanvas.width, tempCanvas.height);
                tempCtx.globalCompositeOperation = 'source-in';
                
                if (layer.material) {
                    const pCanvas = document.createElement('canvas');
                    const pScale = layer.materialScale * (renderScale / 1.0);
                    pCanvas.width = Math.max(1, layer.material.width * pScale);
                    pCanvas.height = Math.max(1, layer.material.height * pScale);
                    const pCtx = pCanvas.getContext('2d');
                    pCtx.imageSmoothingEnabled = true;
                    pCtx.drawImage(layer.material, 0, 0, pCanvas.width, pCanvas.height);
                    const pattern = tempCtx.createPattern(pCanvas, 'repeat');
                    if (pattern && typeof DOMMatrix !== 'undefined') {
                        const matrix = new DOMMatrix();
                        matrix.rotateSelf(layer.materialAngle);
                        pattern.setTransform(matrix);
                    }
                    tempCtx.fillStyle = pattern;
                } else {
                    tempCtx.fillStyle = layer.fillColor;
                }
                
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                tempCtx.globalCompositeOperation = 'source-over';
                
                if (layer.has3DEffect) {
                    ctx.shadowBlur = 10 * (renderScale / 2);
                    ctx.shadowColor = 'rgba(0,0,0,0.35)';
                    ctx.shadowOffsetX = 2 * (renderScale / 2);
                    ctx.shadowOffsetY = 5 * (renderScale / 2);
                }
                ctx.drawImage(tempCanvas, 0, 0);
                ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0;
            }
            isRendering = false;
            renderProgress.textContent = "";
        }

        exportBtn.onclick = async () => {
            showLoading("正在导出物理极限图...");
            setTimeout(async () => {
                try {
                    await renderStudio(true); 
                    const link = document.createElement('a');
                    link.download = `Studio_Render_${Date.now()}.png`;
                    link.href = mainCanvas.toDataURL('image/png', 1.0);
                    link.click();
                    await renderStudio(false); 
                } catch (e) { alert("显存不足"); }
                hideLoading();
            }, 100);
        };

        function updateZoom() {
            if (!originalViewport) return;
            mainCanvas.style.width = (originalViewport.width * (zoom / 100)) + 'px';
            mainCanvas.style.height = (originalViewport.height * (zoom / 100)) + 'px';
            document.getElementById('zoom-text').textContent = zoom + '%';
        }

        document.getElementById('zoom-in').onclick = () => { zoom += 10; updateZoom(); };
        document.getElementById('zoom-out').onclick = () => { zoom = Math.max(10, zoom - 10); updateZoom(); };
        document.getElementById('reset-btn').onclick = () => { if(confirm("重置？")) location.reload(); };
    </script>
</body>
</html>